import { useEffect, useRef, useState, useCallback } from 'react'
import { supabase } from './lib/supabase'
import Monster from './components/Monster'
import LoginScreen from './components/LoginScreen'
import GaugeBar from './components/GaugeBar'
import EggIncubator from './components/EggIncubator'
import { DEFAULT_ELEMENT, getMonsterImage, ELEMENT_LABELS } from './constants/elements'
import { EGG_TYPES, getEggImage, getElementByEggType, getEggTypeByElement, getEggConfig } from './constants/eggs'
import './App.css'

// ì €ì¥ëœ ì•Œì— element/eggType ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì ìš© (ë ˆê±°ì‹œ í˜¸í™˜)
function normalizeEgg(egg) {
  if (!egg) return egg
  const next = { ...egg }
  if (next.element == null) next.element = DEFAULT_ELEMENT
  if (next.eggType == null || !EGG_TYPES.includes(next.eggType)) {
    next.eggType = getEggTypeByElement(next.element)
  }
  return next
}
function normalizeSlots(slots) {
  if (!Array.isArray(slots)) return slots
  return slots.map((egg) => normalizeEgg(egg))
}

const HATCH_MAX = 24 // ë¶€í™” ê²Œì´ì§€ ì´ 24ì¹¸ (0~24)
const HATCH_EGG2_AT = 19 // 19ë²ˆì§¸ ì¹¸ì´ ë˜ëŠ” ìˆœê°„ egg2ë¡œ ì „í™˜
const EGG_SLOT_COUNT = 5 // ì•Œ ìŠ¬ë¡¯ 5ì¹¸
const EGG_SLOT_LOCKED_FROM = 3 // 4ë²ˆì§¸Â·5ë²ˆì§¸ ìŠ¬ë¡¯(ì¸ë±ìŠ¤ 3,4) ì ê¸ˆ â€” ë‚˜ì¤‘ì— ì ê¸ˆí•´ì œ
const SANCTUARY_SLOT_COUNT = 6 // ì•ˆì‹ì²˜ ìŠ¬ë¡¯ 6ì¹¸ (3ì—´ 2í–‰, í™”ë©´ì— ë‹¤ ë“¤ì–´ì˜¤ê²Œ)

// í•„ë“œ ëª¬ìŠ¤í„°: ë ˆë²¨/ê²½í—˜ì¹˜, ë°°ê³ í””/í–‰ë³µ ê²Œì´ì§€
const CARE_EXP_PER_SNACK = 12
const CARE_EXP_PER_PLAY = 18
const CARE_SNACK_MAX_PER_DAY = 5
const CARE_PLAY_MAX_PER_DAY = 5
const GAUGE_MAX = 100
const HUNGER_PER_SNACK = 25
const HAPPINESS_PER_PLAY = 20
const HUNGER_DECAY_HOURS = 12 // 12ì‹œê°„ì´ ì§€ë‚˜ë©´ ë°°ê³ í”” 0
const HAPPINESS_DECAY_PER_DAY = 8
function getExpToNextLevel(level) {
  return 80 + level * 25 // Lv1â†’2: 105, Lv2â†’3: 130, ...
}
function todayStr() {
  const d = new Date()
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`
}
function parseDateStr(str) {
  if (!str || str.length !== 10) return null
  const [y, m, d] = str.split('-').map(Number)
  if (isNaN(y) || isNaN(m) || isNaN(d)) return null
  return new Date(y, m - 1, d)
}
function daysBetween(aStr, bStr) {
  const a = parseDateStr(aStr)
  const b = parseDateStr(bStr)
  if (!a || !b) return 0
  return Math.max(0, Math.floor((b - a) / 86400000))
}
function normalizeFieldMonster(m) {
  if (!m) return m
  const level = Math.max(1, m.level ?? 1)
  const exp = Math.max(0, m.exp ?? 0)
  const today = todayStr()
  const careDate = m.careDate ?? today
  const careSnack = careDate === today ? (m.careSnack ?? 0) : 0
  const carePlay = careDate === today ? (m.carePlay ?? 0) : 0
  const hunger = Math.max(0, Math.min(GAUGE_MAX, m.hunger ?? GAUGE_MAX))
  const lastHungerUpdatedAt = m.lastHungerUpdatedAt ?? Date.now()
  let happiness = Math.max(0, Math.min(GAUGE_MAX, m.happiness ?? GAUGE_MAX))
  const lastDecay = m.lastDecayDate ?? today
  const days = daysBetween(lastDecay, today)
  if (days > 0) {
    happiness = Math.max(0, happiness - days * HAPPINESS_DECAY_PER_DAY)
  }
  return { ...m, level, exp, careDate: today, careSnack, carePlay, hunger, lastHungerUpdatedAt, happiness, lastDecayDate: today }
}
/** ë°°ê³ í””: 12ì‹œê°„ì´ ì§€ë‚˜ë©´ 0. ì €ì¥ëœ hunger ê¸°ì¤€ìœ¼ë¡œ ê²½ê³¼ ì‹œê°„ë§Œí¼ ê°ì†Œ */
function getCurrentHunger(m) {
  if (!m) return 0
  const stored = m.hunger ?? GAUGE_MAX
  const updatedAt = m.lastHungerUpdatedAt ?? Date.now()
  const elapsedHours = (Date.now() - updatedAt) / 3600000
  const decay = (elapsedHours / HUNGER_DECAY_HOURS) * GAUGE_MAX
  return Math.max(0, Math.min(GAUGE_MAX, stored - decay))
}

/** ëª¬ìŠ¤í„° í‘œì‹œ ì´ë¦„: ì‚¬ìš©ì ì§€ì • nameì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ì†ì„± ê¸°ë°˜ ê¸°ë³¸ëª… */
function getDisplayName(m) {
  if (!m) return ''
  const custom = (m.name ?? '').trim()
  if (custom) return custom
  const label = ELEMENT_LABELS[m.element] ?? m.element ?? 'ë°ì´ëª¬'
  return `${label} ë°ì´ëª¬`
}

// ë‚¨ì€ ms â†’ "HH:MM" (ì˜ˆ: 23:59, 01:10)
function formatRemainingTime(ms) {
  const totalSec = Math.max(0, Math.floor(ms / 1000))
  const h = Math.floor(totalSec / 3600)
  const m = Math.floor((totalSec % 3600) / 60)
  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`
}

// ìŠ¬ë¡¯ì—ì„œ ì•Œ ì œê±° í›„ ì™¼ìª½ìœ¼ë¡œ ë‹¹ê¸°ê¸° (0~2ë²ˆë§Œ ì‚¬ìš©, 3~4 ì ê¸ˆ)
function compactSlots(slots, removedIndex) {
  const unlocked = [...(slots.slice(0, 3))]
  unlocked[removedIndex] = null
  const compacted = unlocked.filter((egg) => egg != null)
  return [...compacted, null, null, null, null].slice(0, 5)
}

function App() {
  const [session, setSession] = useState(null)
  const [user, setUser] = useState(null)
  const [nicknamePrompt, setNicknamePrompt] = useState(false) // ë‹‰ë„¤ì„ ì…ë ¥ í™”ë©´ í‘œì‹œ ì—¬ë¶€
  const [nicknameInput, setNicknameInput] = useState('') // ë‹‰ë„¤ì„ ì…ë ¥ê°’
  const [nicknameError, setNicknameError] = useState('') // ë‹‰ë„¤ì„ ì—ëŸ¬ ë©”ì‹œì§€
  const [mood, setMood] = useState('í‰ì˜¨')
  const [incubatorEggs, setIncubatorEggs] = useState([null, null, null, null, null]) // ë¶€í™”ì¥ì¹˜ 5ì¹¸. 0~2 ì‚¬ìš©, 3~4 ì ê¸ˆ
  const [currentIncubatorIndex, setCurrentIncubatorIndex] = useState(0) // í˜„ì¬ ë³´ì´ëŠ” ë¶€í™”ì¥ì¹˜ ì¸ë±ìŠ¤
  const [slots, setSlots] = useState([null, null, null, null, null]) // ìŠ¬ë¡¯ 5ì¹¸. 0~2 ì‚¬ìš©, 3~4 ì ê¸ˆ
  const [fieldMonster, setFieldMonster] = useState(null) // í•„ë“œ ë©”ì¸ ëª¬ìŠ¤í„°. nullì´ë©´ ì—†ìŒ
  const [fieldMonsterPos, setFieldMonsterPos] = useState({ x: 50, y: 50 }) // í•„ë“œ ëª¬ìŠ¤í„°: í™”ë©´ ì •ì¤‘ì•™(50%, 50%)
  const [fieldMonsterMaxWidthPx, setFieldMonsterMaxWidthPx] = useState(null) // field-area ê¸°ì¤€ ëª¬ìŠ¤í„° ìµœëŒ€ ë„ˆë¹„(px)
  const [fieldLikeHearts, setFieldLikeHearts] = useState([]) // í„°ì¹˜ ì‹œ í•˜íŠ¸ ì´í™íŠ¸ [{ id, batchId }]
  const [fieldMonsterLiking, setFieldMonsterLiking] = useState(false) // í„°ì¹˜ ì‹œ ëª¬ìŠ¤í„° ì‚´ì§ ì»¤ì¡Œë‹¤ ì‘ì•„ì§
  const [fieldCareExpFlash, setFieldCareExpFlash] = useState(0) // ëŒë´ì£¼ê¸° ì‹œ "+N EXP" ì ê¹ í‘œì‹œ
  const [fieldHungerTick, setFieldHungerTick] = useState(0) // ë°°ê³ í”” ì‹œê°„ ê²½ê³¼ë¡œ ê²Œì´ì§€ ê°±ì‹ ìš© (60ì´ˆë§ˆë‹¤ +1)
  const [sanctuary, setSanctuary] = useState([null, null, null, null, null, null]) // ì•ˆì‹ì²˜ ìŠ¬ë¡¯ 6ì¹¸
  const fieldAreaRef = useRef(null)
  const fieldLikeTimeoutRef = useRef(null)
  const fieldMonsterTouchStartedRef = useRef(false) // í„°ì¹˜ê°€ ëª¬ìŠ¤í„° ìœ„ì—ì„œ ì‹œì‘í–ˆì„ ë•Œë§Œ true
  const fieldMonsterClickSkipRef = useRef(false) // í„°ì¹˜ í›„ ë‚˜ì˜¤ëŠ” í´ë¦­ì€ ë¬´ì‹œ
  const fieldMonsterPointerDownRef = useRef(false) // í¬ì¸í„°/ë§ˆìš°ìŠ¤ê°€ ëª¬ìŠ¤í„° ìœ„ì—ì„œ down ëì„ ë•Œë§Œ true
  const fieldTabShownAtRef = useRef(0) // í•„ë“œ íƒ­ì´ ë§ˆì§€ë§‰ìœ¼ë¡œ í‘œì‹œëœ ì‹œê°(ms). ì´ ì‹œê° ì§í›„ ì§§ì€ ë™ì•ˆ ëª¬ìŠ¤í„° í„°ì¹˜ ë¬´ì‹œ
  const fieldMonsterDivRef = useRef(null) // ëª¬ìŠ¤í„° div (íƒ­ ì´íƒˆ ì‹œ í¬ì¸í„° ìº¡ì²˜ í•´ì œìš©)
  const fieldMonsterPointerIdRef = useRef(null) // ëª¬ìŠ¤í„°ê°€ ìº¡ì²˜ ì¤‘ì¸ pointerId
  const fieldPointerReleasedAtRef = useRef(0) // í¬ì¸í„° í•´ì œí•œ ì‹œê°(ms). í•´ì œ ì§í›„ ì§§ì€ ë™ì•ˆ í„°ì¹˜ ë¬´ì‹œ(ë¹ ë¥¸ íƒ­ ì „í™˜ ëŒ€ë¹„)
  const [note, setNote] = useState('')
  const [tab, setTab] = useState('egg')
  const [hatchDismissed, setHatchDismissed] = useState(false)
  const [confirmHatchOpen, setConfirmHatchOpen] = useState(false) // 'ë¶€í™”ë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?' ë‹¤ì´ì–¼ë¡œê·¸
  const [slotToHatch, setSlotToHatch] = useState(null) // ë¶€í™” í™•ì¸ ì‹œ ì„ íƒí•œ ìŠ¬ë¡¯ ì¸ë±ìŠ¤
  const [slotLockedAlertOpen, setSlotLockedAlertOpen] = useState(false) // 'ì´ ìŠ¬ë¡¯ì€ ì•„ì§ ì ê²¨ìˆìŠµë‹ˆë‹¤' ì•Œë¦¼
  const [slotFullAlertOpen, setSlotFullAlertOpen] = useState(false) // 'ë¶€í™”ì¥ì¹˜ì— ì´ë¯¸ ì•Œì´ ìˆìŠµë‹ˆë‹¤' ì•Œë¦¼
  const [sanctuaryToFieldOpen, setSanctuaryToFieldOpen] = useState(false) // 'í•„ë“œë¡œ ë‚´ë³´ë‚´ì‹œê² ìŠµë‹ˆê¹Œ?' ë‹¤ì´ì–¼ë¡œê·¸
  const [sanctuarySlotToField, setSanctuarySlotToField] = useState(null) // í•„ë“œë¡œ ë‚´ë³´ë‚¼ ì•ˆì‹ì²˜ ìŠ¬ë¡¯ ì¸ë±ìŠ¤
  const [monsterNameEditTarget, setMonsterNameEditTarget] = useState(null) // 'field' | null â€” í•„ë“œ ëª¬ìŠ¤í„° ì´ë¦„ ìˆ˜ì • ëª¨ë‹¬
  const [monsterNameEditValue, setMonsterNameEditValue] = useState('') // ì´ë¦„ ì…ë ¥ í•„ë“œ ê°’
  const [sessionExpiredMessage, setSessionExpiredMessage] = useState(null) // 401 ì‹œ "ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤" ë“±
  const [devCoords, setDevCoords] = useState({ x: 0, y: 0 })
  const [devViewport, setDevViewport] = useState({ w: 0, h: 0 })
  const noteTimerRef = useRef(null)
  const holdTimeoutRef = useRef(null)
  const holdIntervalRef = useRef(null)
  const nextTickAtRef = useRef(0) // ë‹¤ìŒ ë¶€í™” ê²Œì´ì§€ +1 ì‹œê°(ms)
  const dataLoadedRef = useRef(false) // DBì—ì„œ ë°ì´í„° ë¡œë“œ ì™„ë£Œ ì—¬ë¶€ (í•« ë¦¬ë¡œë“œ ì‹œ ë¹ˆ stateë¡œ ë®ì–´ì“°ê¸° ë°©ì§€)
  const [remainingMs, setRemainingMs] = useState(0) // ë¶€í™”ê¹Œì§€ ë‚¨ì€ ms (í‘œì‹œìš©)
  const [gaugeProgress, setGaugeProgress] = useState(0) // í˜„ì¬ 1ì‹œê°„ êµ¬ê°„ ë‚´ ì§„í–‰ë¥  0~1 (ì‹¤ì‹œê°„ ì±„ì›€)

  const currentEgg = incubatorEggs[currentIncubatorIndex]
  const affection = currentEgg ? currentEgg.affection : 0
  const bondStage = currentEgg ? (currentEgg.affection >= HATCH_EGG2_AT ? 2 : 1) : 1

  // Supabaseì—ì„œ ê°€ì ¸ì˜¨ userDataë¥¼ stateì— ë°˜ì˜
  const applyUserDataToState = (userData) => {
    if (!userData) return
    setUser(userData)
    setMood(userData.mood || 'í‰ì˜¨')

    // center_egg ì²˜ë¦¬
    if (userData.center_egg) {
      setCenterEgg(normalizeEgg(userData.center_egg))
    } else {
      const a = Math.max(0, Math.min(HATCH_MAX, userData.affection ?? 0))
      const bs = userData.bond_stage === 2 && a < HATCH_EGG2_AT ? 2 : a >= HATCH_EGG2_AT ? 2 : 1
      setCenterEgg({ affection: a, bondStage: bs, element: DEFAULT_ELEMENT, eggType: 'fire' })
    }

    // slots ì²˜ë¦¬
    if (Array.isArray(userData.slots)) {
      setSlots(normalizeSlots(userData.slots))
    } else {
      setSlots([null, null, null, null, null])
    }

    // field_monster ì²˜ë¦¬
    setFieldMonster(normalizeFieldMonster(userData.field_monster ?? null))

    // sanctuary ì²˜ë¦¬
    const s = Array.isArray(userData.sanctuary) ? userData.sanctuary : []
    const pad = [...s]
    while (pad.length < SANCTUARY_SLOT_COUNT) pad.push(null)
    setSanctuary(pad.slice(0, SANCTUARY_SLOT_COUNT).map((m) => (m ? normalizeFieldMonster(m) : null)))

    // next_tick_at ì²˜ë¦¬
    nextTickAtRef.current = (userData.next_tick_at != null && userData.next_tick_at > 0) ? userData.next_tick_at : Date.now() + 3600000
  }

  // Supabase ì¸ì¦ ìƒíƒœ ê´€ë¦¬
  useEffect(() => {
    // í˜„ì¬ ì„¸ì…˜ í™•ì¸
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      if (session?.user) {
        loadUserData(session.user.id)
      }
    })

    // ì¸ì¦ ìƒíƒœ ë³€ê²½ ê°ì§€
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session)
      if (session?.user) {
        loadUserData(session.user.id)
      } else {
        setUser(null)
      }
    })

    return () => subscription.unsubscribe()
  }, [])

  // Supabaseì—ì„œ ìœ ì € ë°ì´í„° ë¡œë“œ
  async function loadUserData(userId) {
    // 1. users í…Œì´ë¸”ì—ì„œ ê¸°ë³¸ ì •ë³´ í™•ì¸
    let { data: userData, error: userError } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single()

    if (userError && userError.code === 'PGRST116') {
      // ìœ ì € ì—†ìŒ â†’ ìƒì„±
      userData = await createInitialUser(userId)

      if (!userData) {
        console.error('Failed to create initial user')
        await supabase.auth.signOut()
        return
      }
    }

    if (!userData) {
      console.error('No user data available')
      return
    }

    // user_idê°€ ì„ì‹œ ID(temp_ë¡œ ì‹œì‘)ë©´ ë‹‰ë„¤ì„ ì…ë ¥ í™”ë©´ í‘œì‹œ
    if (userData && userData.user_id && userData.user_id.startsWith('temp_')) {
      console.log('Setting nickname prompt to true, user_id:', userData.user_id)
      setNicknamePrompt(true)
      return
    }

    // 2. monsters í…Œì´ë¸”ì—ì„œ ëª¬ìŠ¤í„°/ì•Œ ë°ì´í„° ë¡œë“œ
    const { data: monsters, error: monstersError } = await supabase
      .from('monsters')
      .select('*')
      .eq('user_id', userId)

    if (monstersError) {
      console.error('Failed to load monsters:', monstersError)
      return
    }

    // 3. monsters ë°ì´í„°ë¥¼ stateì— ë°˜ì˜
    applyMonstersToState(monsters || [], userData)
  }

  // ì²« ë¡œê·¸ì¸ ì‹œ users í…Œì´ë¸”ì— ìœ ì € ìƒì„±
  async function createInitialUser(userId) {
    // ì„ì‹œ user_id ìƒì„± (UUID ê¸°ë°˜)
    const tempUserId = `temp_${crypto.randomUUID().slice(0, 8)}`

    const { data, error } = await supabase
      .from('users')
      .insert({
        id: userId,
        user_id: tempUserId,
        created_at: Date.now(),
        updated_at: Date.now(),
        mood: 'í‰ì˜¨',
      })
      .select()
      .single()

    if (error) {
      console.error('Failed to create user:', error)
      return null
    }

    return data
  }

  // ë‹‰ë„¤ì„ ì œì¶œ
  async function handleNicknameSubmit() {
    const nickname = nicknameInput.trim()

    if (nickname.length < 2 || nickname.length > 10) {
      setNicknameError('ë‹‰ë„¤ì„ì€ 2-10ìì—¬ì•¼ í•©ë‹ˆë‹¤.')
      return
    }

    // user_id ì—…ë°ì´íŠ¸
    const { error } = await supabase
      .from('users')
      .update({ user_id: nickname })
      .eq('id', session.user.id)

    if (error) {
      console.error('Failed to create user:', error)
      if (error.code === '23505') {
        setNicknameError('ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤.')
      } else {
        setNicknameError('ë‹‰ë„¤ì„ ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.')
      }
      return
    }

    // ì„±ê³µ ì‹œ ë‹‰ë„¤ì„ ì…ë ¥ í™”ë©´ ë‹«ê³  ë°ì´í„° ë¡œë“œ
    setNicknamePrompt(false)
    setNicknameInput('')
    setNicknameError('')
    await loadUserData(session.user.id)
  }

  // monsters ë°ì´í„°ë¥¼ stateì— ë°˜ì˜
  function applyMonstersToState(monsters, userData) {
    setUser(userData ? { ...userData, userId: userData.user_id } : { id: session?.user?.id, mood: 'í‰ì˜¨', userId: 'Guest' })
    setMood(userData?.mood || 'í‰ì˜¨')

    // next_tick_at ë¡œë“œ
    if (userData?.next_tick_at) {
      nextTickAtRef.current = userData.next_tick_at
    }

    // center_egg ì°¾ê¸°
    const centerEggMonster = monsters.find(m => m.location === 'center_egg')
    if (centerEggMonster) {
      setCenterEgg({
        id: centerEggMonster.id, // DBì˜ id í¬í•¨
        affection: centerEggMonster.affection || 0,
        bondStage: centerEggMonster.bond_stage || 1,
        element: centerEggMonster.element,
        eggType: centerEggMonster.egg_type || 'fire',
      })
    } else {
      setCenterEgg(null)
    }

    // slots ì°¾ê¸°
    const newSlots = [null, null, null, null, null]
    for (let i = 0; i < 5; i++) {
      const slotMonster = monsters.find(m => m.location === `slot_${i}`)
      if (slotMonster) {
        newSlots[i] = {
          id: slotMonster.id, // DBì˜ id í¬í•¨
          affection: slotMonster.affection || 0,
          bondStage: slotMonster.bond_stage || 1,
          element: slotMonster.element,
          eggType: slotMonster.egg_type || 'fire',
        }
      }
    }
    setSlots(newSlots)

    // field_monster ì°¾ê¸°
    const fieldMonster = monsters.find(m => m.location === 'field')
    if (fieldMonster) {
      setFieldMonster({
        id: fieldMonster.id, // DBì˜ id í¬í•¨
        element: fieldMonster.element,
        level: fieldMonster.level || 1,
        exp: fieldMonster.exp || 0,
        hunger: fieldMonster.hunger || 100,
        happiness: fieldMonster.happiness || 100,
        name: fieldMonster.nickname,
      })
    } else {
      setFieldMonster(null)
    }

    // sanctuary ì°¾ê¸°
    const newSanctuary = [null, null, null, null, null, null]
    for (let i = 0; i < 6; i++) {
      const sanctuaryMonster = monsters.find(m => m.location === `sanctuary_${i}`)
      if (sanctuaryMonster) {
        newSanctuary[i] = {
          id: sanctuaryMonster.id, // DBì˜ id í¬í•¨
          element: sanctuaryMonster.element,
          level: sanctuaryMonster.level || 1,
          exp: sanctuaryMonster.exp || 0,
          hunger: sanctuaryMonster.hunger || 100,
          happiness: sanctuaryMonster.happiness || 100,
          name: sanctuaryMonster.nickname,
        }
      }
    }
    setSanctuary(newSanctuary)

    // ë°ì´í„° ë¡œë“œ ì™„ë£Œ í”Œë˜ê·¸ ì„¤ì •
    dataLoadedRef.current = true
  }

  // íƒ­/ì°½ í¬ì»¤ìŠ¤ ì‹œ Supabaseì—ì„œ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  useEffect(() => {
    const onFocus = async () => {
      if (!session?.user || !user) return
      await loadUserData(session.user.id)
    }
    window.addEventListener('visibilitychange', onFocus)
    return () => window.removeEventListener('visibilitychange', onFocus)
  }, [session, user])

  // Supabaseì— monsters ë°ì´í„° ì €ì¥
  const saveMonstersToSupabase = useCallback(async () => {
    if (!session?.user?.id) return

    try {
      const now = Date.now()

      // ê¸°ì¡´ monsters ë°ì´í„° ëª¨ë‘ ì‚­ì œ
      await supabase
        .from('monsters')
        .delete()
        .eq('user_id', session.user.id)

      const monstersToInsert = []

      // centerEgg ì €ì¥
      if (centerEgg) {
        const eggData = {
          user_id: session.user.id,
          location: 'center_egg',
          element: centerEgg.element,
          egg_type: centerEgg.eggType,
          affection: centerEgg.affection || 0,
          bond_stage: centerEgg.bondStage || 1,
          is_hatched: false,
          created_at: now,
          updated_at: now,
        }
        // ê¸°ì¡´ idê°€ ìˆìœ¼ë©´ í¬í•¨ (DB ë ˆì½”ë“œ ìœ ì§€)
        if (centerEgg.id) {
          eggData.id = centerEgg.id
        }
        console.log('ğŸ’¾ Saving centerEgg:', eggData)
        monstersToInsert.push(eggData)
      }

      // slots ì €ì¥
      slots.forEach((egg, index) => {
        if (egg) {
          const slotData = {
            user_id: session.user.id,
            location: `slot_${index}`,
            element: egg.element,
            egg_type: egg.eggType,
            affection: egg.affection || 0,
            bond_stage: egg.bondStage || 1,
            is_hatched: false,
            created_at: now,
            updated_at: now,
          }
          // ê¸°ì¡´ idê°€ ìˆìœ¼ë©´ í¬í•¨ (DB ë ˆì½”ë“œ ìœ ì§€)
          if (egg.id) {
            slotData.id = egg.id
          }
          console.log(`ğŸ’¾ Saving slot ${index}:`, slotData)
          monstersToInsert.push(slotData)
        }
      })

      // fieldMonster ì €ì¥
      if (fieldMonster) {
        const fieldData = {
          user_id: session.user.id,
          location: 'field',
          element: fieldMonster.element,
          level: fieldMonster.level || 1,
          exp: fieldMonster.exp || 0,
          hunger: fieldMonster.hunger || 100,
          happiness: fieldMonster.happiness || 100,
          nickname: fieldMonster.name || null,
          is_hatched: true,
          created_at: now,
          updated_at: now,
        }
        // ê¸°ì¡´ idê°€ ìˆìœ¼ë©´ í¬í•¨ (DB ë ˆì½”ë“œ ìœ ì§€)
        if (fieldMonster.id) {
          fieldData.id = fieldMonster.id
        }
        monstersToInsert.push(fieldData)
      }

      // sanctuary ì €ì¥
      sanctuary.forEach((monster, index) => {
        if (monster) {
          const sanctuaryData = {
            user_id: session.user.id,
            location: `sanctuary_${index}`,
            element: monster.element,
            level: monster.level || 1,
            exp: monster.exp || 0,
            hunger: monster.hunger || 100,
            happiness: monster.happiness || 100,
            nickname: monster.name || null,
            is_hatched: true,
            created_at: now,
            updated_at: now,
          }
          // ê¸°ì¡´ idê°€ ìˆìœ¼ë©´ í¬í•¨ (DB ë ˆì½”ë“œ ìœ ì§€)
          if (monster.id) {
            sanctuaryData.id = monster.id
          }
          monstersToInsert.push(sanctuaryData)
        }
      })

      // monsters í…Œì´ë¸”ì— ì¼ê´„ ì €ì¥
      if (monstersToInsert.length > 0) {
        const { error } = await supabase
          .from('monsters')
          .insert(monstersToInsert)

        if (error) {
          console.error('âŒ Failed to save monsters:', error)
          console.error('âŒ Error details:', JSON.stringify(error, null, 2))
          console.error('âŒ Data attempted:', monstersToInsert)
        } else {
          console.log('âœ… Saved monsters:', monstersToInsert.length)
        }
      }

      // users í…Œì´ë¸”ì— ë©”íƒ€ë°ì´í„° ì €ì¥
      await supabase
        .from('users')
        .update({
          mood,
          next_tick_at: nextTickAtRef.current,
          updated_at: now,
        })
        .eq('id', session.user.id)
    } catch (error) {
      console.error('Failed to save data:', error)
    }
  }, [session?.user?.id, centerEgg, slots, fieldMonster, sanctuary, mood])

  // ë°ì´í„° ë³€ê²½ ì‹œ ì €ì¥ (500ms debounceë¡œ ë¬´í•œ ë£¨í”„ ë°©ì§€)
  useEffect(() => {
    if (!user || !session?.user) return
    // ë°ì´í„° ë¡œë“œê°€ ì™„ë£Œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì €ì¥í•˜ì§€ ì•ŠìŒ (í•« ë¦¬ë¡œë“œ ì‹œ ë¹ˆ stateë¡œ ë®ì–´ì“°ê¸° ë°©ì§€)
    if (!dataLoadedRef.current) return

    const timer = setTimeout(() => {
      saveMonstersToSupabase()
    }, 500)

    return () => clearTimeout(timer)
  }, [user, session, saveMonstersToSupabase])

  // ê°œë°œìš©: ë§ˆìš°ìŠ¤/í„°ì¹˜ ì¢Œí‘œ í‘œì‹œ
  useEffect(() => {
    const update = (e) => {
      const x = e.touches ? e.touches[0].clientX : e.clientX
      const y = e.touches ? e.touches[0].clientY : e.clientY
      setDevCoords({ x, y })
    }
    window.addEventListener('mousemove', update)
    window.addEventListener('touchmove', update, { passive: true })
    return () => {
      window.removeEventListener('mousemove', update)
      window.removeEventListener('touchmove', update)
    }
  }, [])

  // ê°œë°œìš©: ë·°í¬íŠ¸ í¬ê¸° (í™”ë©´ ë„ˆë¹„Ã—ë†’ì´)
  useEffect(() => {
    const update = () => setDevViewport({ w: window.innerWidth, h: window.innerHeight })
    update()
    window.addEventListener('resize', update)
    return () => window.removeEventListener('resize', update)
  }, [])

  // ë¶€í™” 1ì‹œê°„ë§ˆë‹¤ 1ì”© ìë™ ì¦ê°€ (ê°€ìš´ë° ì•Œì´ ìˆì„ ë•Œë§Œ). nextTickAtì€ ë¡œë“œ ì‹œ ë³µì›ë˜ë¯€ë¡œ ì—¬ê¸°ì„œ ë®ì–´ì“°ì§€ ì•ŠìŒ
  useEffect(() => {
    if (!user || !centerEgg) return
    if (nextTickAtRef.current <= 0) nextTickAtRef.current = Date.now() + 3600000
    const interval = setInterval(() => {
      setCenterEgg((prev) =>
        prev ? { ...prev, affection: Math.min(HATCH_MAX, prev.affection + 1) } : prev
      )
      nextTickAtRef.current = Date.now() + 3600000
    }, 3600000)
    return () => clearInterval(interval)
  }, [user, centerEgg])

  // ë¶€í™”ê¹Œì§€ ë‚¨ì€ ì‹œê°„ í‘œì‹œ(1ì´ˆë§ˆë‹¤ ê°±ì‹ ) â€” ê²Œì´ì§€ì— ë”°ë¼: ë‹¤ìŒ í‹±ê¹Œì§€ + ê·¸ ë‹¤ìŒ ë‚¨ì€ ì‹œê°„
  useEffect(() => {
    if (!centerEgg || affection >= HATCH_MAX) return
    const update = () => {
      const untilNextTick = Math.max(0, nextTickAtRef.current - Date.now())
      const fullHoursAfter = Math.max(0, (HATCH_MAX - affection - 1) * 3600000)
      setRemainingMs(untilNextTick + fullHoursAfter)
    }
    update()
    const interval = setInterval(update, 1000)
    return () => clearInterval(interval)
  }, [centerEgg, affection])

  // ê²Œì´ì§€ ì‹¤ì‹œê°„ ì±„ì›€: í˜„ì¬ 1ì‹œê°„ êµ¬ê°„ ì§„í–‰ë¥ ì„ ìì£¼ ê°±ì‹  (ë¶€ë“œëŸ½ê²Œ ì°¨ì˜¤ë¥´ê²Œ)
  useEffect(() => {
    if (!centerEgg) {
      setGaugeProgress(0)
      return
    }
    if (affection >= HATCH_MAX) {
      setGaugeProgress(1)
      return
    }
    const update = () => {
      const msUntilNext = nextTickAtRef.current - Date.now()
      const progress = Math.min(1, Math.max(0, 1 - msUntilNext / 3600000))
      setGaugeProgress(progress)
    }
    update()
    const interval = setInterval(update, 200)
    return () => clearInterval(interval)
  }, [centerEgg, affection])

  // ì–¸ë§ˆìš´íŠ¸ ì‹œ ì¦ê° ë²„íŠ¼ ëˆ„ë¦„ íƒ€ì´ë¨¸ ì •ë¦¬
  useEffect(() => {
    return () => clearHold()
  }, [])



  const handleLogout = async () => {
    await supabase.auth.signOut()
    setSession(null)
    setUser(null)
    setMood('í‰ì˜¨')
    setCenterEgg(null)
    setSlots([null, null, null, null, null])
    setFieldMonster(null)
    setSanctuary([null, null, null, null, null, null])
    setNote('')
    setHatchDismissed(false)
    setConfirmHatchOpen(false)
    setSlotToHatch(null)
  }

  const handleMonsterTouch = () => {
    if (!user) return
  }

  // ë¶€í™” ì™„ë£Œ í›„ í™”ë©´ ë‹«ì„ ë•Œ: ëª¬ìŠ¤í„°ëŠ” í•„ë“œ(ë¹„ì–´ ìˆìœ¼ë©´) ë˜ëŠ” ì•ˆì‹ì²˜ë¡œ, ê°€ìš´ë°ëŠ” ë¹ˆ ìƒíƒœ
  // ë¶€í™” ì™„ë£Œ í›„: í•„ë“œ ë¹„ì—ˆìœ¼ë©´ í•„ë“œë¡œ, í•„ë“œì— ëª¬ìŠ¤í„° ìˆìœ¼ë©´ ì•ˆì‹ì²˜ ì²« ë¹ˆ ìŠ¬ë¡¯ìœ¼ë¡œ
  const handleHatchDismiss = () => {
    const monster = normalizeFieldMonster({
      element: centerEgg?.element ?? DEFAULT_ELEMENT,
      id: Date.now(),
      name: '',
      level: 1,
      exp: 0,
      careDate: todayStr(),
      careSnack: 0,
      carePlay: 0,
      hunger: 80,
      lastHungerUpdatedAt: Date.now(),
      happiness: 80,
      lastDecayDate: todayStr(),
    })
    if (fieldMonster == null) {
      setFieldMonster(monster)
    } else {
      setSanctuary((prev) => {
        const base = prev.length >= SANCTUARY_SLOT_COUNT ? prev : [...prev, ...Array(SANCTUARY_SLOT_COUNT).fill(null)].slice(0, SANCTUARY_SLOT_COUNT)
        const i = base.findIndex((m) => m == null)
        if (i === -1) return base
        const next = [...base]
        next[i] = monster
        return next
      })
    }
    setHatchDismissed(true)
    setCenterEgg(null)
  }

  // ìŠ¬ë¡¯ ì•Œ í´ë¦­: ê°€ìš´ë°ì— ì•Œì´ ì—†ì„ ë•Œë§Œ 'ë¶€í™”ë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?' í‘œì‹œ
  const handleSlotClick = (index) => {
    // ì ê¸ˆ ìŠ¬ë¡¯ í´ë¦­ ì‹œ ì•Œë¦¼ ë‹¤ì´ì–¼ë¡œê·¸
    if (index >= EGG_SLOT_LOCKED_FROM) {
      setSlotLockedAlertOpen(true)
      return
    }

    const egg = slots[index]
    // ë¹ˆ ìŠ¬ë¡¯ì€ ë¬´ì‹œ
    if (!egg) return

    // ë¶€í™”ì¥ì¹˜ì— ì´ë¯¸ ì•Œì´ ìˆìœ¼ë©´ ì•Œë¦¼ ë‹¤ì´ì–¼ë¡œê·¸
    if (centerEgg != null) {
      setSlotFullAlertOpen(true)
      return
    }

    setSlotToHatch(index)
    setConfirmHatchOpen(true)
  }

  // 'ì•Œì„ ë¶€í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?' ìˆ˜ë½ â†’ ì•Œì„ ê°€ìš´ë°ë¡œ, ìŠ¬ë¡¯ì—ì„œ ì œê±°, ì™¼ìª½ìœ¼ë¡œ ë‹¹ê¸°ê¸°
  const handleConfirmHatchAccept = () => {
    if (slotToHatch == null) {
      setConfirmHatchOpen(false)
      return
    }
    const egg = slots[slotToHatch]
    if (!egg) {
      setConfirmHatchOpen(false)
      setSlotToHatch(null)
      return
    }
    // Set center egg first, then remove from slots to prevent duplicate egg display
    // Using functional update ensures we work with the latest state
    setCenterEgg(egg)
    setSlots(prevSlots => compactSlots(prevSlots, slotToHatch))
    setHatchDismissed(false)
    setConfirmHatchOpen(false)
    setSlotToHatch(null)
  }

  const handleConfirmHatchReject = () => {
    setConfirmHatchOpen(false)
    setSlotToHatch(null)
  }

  const createEgg = (eggType) => ({
    id: crypto.randomUUID(),
    affection: 0,
    bondStage: 1,
    element: getElementByEggType(eggType),
    eggType,
    created_at: Date.now(),
  })

  // ì´ˆê¸°í™”: ìŠ¬ë¡¯ì— ì•Œ 3ê°œ â€” ë¶ˆì†ì„±Â·ë¬¼ì†ì„± ë‘˜ ë‹¤ ë‚˜ì˜¤ê²Œ (1 classic, 1 glow, 1 ëœë¤)
  const handleResetSlots = async () => {
    if (!session?.user?.id) return

    try {
      // 1. ë¨¼ì € ê¸°ì¡´ ìŠ¬ë¡¯ ì•Œë“¤ì„ DBì—ì„œ ì‚­ì œ
      const slotsToDelete = slots.filter(egg => egg != null).map(egg => egg.id).filter(id => id)

      if (slotsToDelete.length > 0) {
        const { error: deleteError } = await supabase
          .from('monsters')
          .delete()
          .in('id', slotsToDelete)

        if (deleteError) {
          console.error('âŒ Failed to delete old slot eggs:', deleteError)
          return
        }
        console.log('ğŸ—‘ï¸ Deleted old slot eggs:', slotsToDelete.length)
      }

      // 2. ìƒˆ ì•Œ 3ê°œ ìƒì„±
      const third = EGG_TYPES[Math.floor(Math.random() * EGG_TYPES.length)]
      const three = [
        createEgg('classic'),
        createEgg('glow'),
        createEgg(third),
      ]

      // ëœë¤ ì„ê¸°
      for (let i = three.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [three[i], three[j]] = [three[j], three[i]]
      }

      // 3. DBì— ìƒˆ ì•Œ INSERT
      const now = Date.now()
      const newEggsData = three.map((egg, index) => ({
        id: egg.id,
        user_id: session.user.id,
        location: `slot_${index}`,
        element: egg.element,
        egg_type: egg.eggType,
        affection: 0,
        bond_stage: 1,
        is_hatched: false,
        created_at: now,
        updated_at: now,
      }))

      const { error: insertError } = await supabase
        .from('monsters')
        .insert(newEggsData)

      if (insertError) {
        console.error('âŒ Failed to insert new eggs:', insertError)
        return
      }

      console.log('âœ… Inserted new eggs:', newEggsData.length)

      // 4. state ì—…ë°ì´íŠ¸
      setSlots([...three, null, null])
    } catch (error) {
      console.error('âŒ Failed to reset slots:', error)
    }
  }

  // ì•Œ ì‚­ì œ: ëª¨ë“  ìŠ¬ë¡¯ ì•Œ ì œê±° (ë¶€í™”ì¥ì¹˜ ì•Œì€ ìœ ì§€)
  const handleDeleteAllSlots = async () => {
    if (!session?.user?.id) return

    try {
      // 1. DBì—ì„œ ìŠ¬ë¡¯ ì•Œë“¤ ì‚­ì œ
      const slotsToDelete = slots.filter(egg => egg != null).map(egg => egg.id).filter(id => id)

      if (slotsToDelete.length > 0) {
        const { error: deleteError } = await supabase
          .from('monsters')
          .delete()
          .in('id', slotsToDelete)

        if (deleteError) {
          console.error('âŒ Failed to delete slot eggs:', deleteError)
          return
        }
        console.log('ğŸ—‘ï¸ Deleted all slot eggs:', slotsToDelete.length)
      }

      // 2. state ì—…ë°ì´íŠ¸ (ìŠ¬ë¡¯ë§Œ ë¹„ì›€, ë¶€í™”ì¥ì¹˜ëŠ” ìœ ì§€)
      setSlots([null, null, null, null, null])
    } catch (error) {
      console.error('âŒ Failed to delete all slots:', error)
    }
  }

  // ì¦ê° ë²„íŠ¼ ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ì—°ì† ì¦ê° â€” ëŒ€ê¸° í›„ ë°˜ë³µ
  const clearHold = () => {
    if (holdTimeoutRef.current) {
      clearTimeout(holdTimeoutRef.current)
      holdTimeoutRef.current = null
    }
    if (holdIntervalRef.current) {
      clearInterval(holdIntervalRef.current)
      holdIntervalRef.current = null
    }
  }

  const startHoldDecrease = () => {
    if (!centerEgg) return
    clearHold()
    holdTimeoutRef.current = setTimeout(() => {
      holdTimeoutRef.current = null
      holdIntervalRef.current = setInterval(() => {
        setCenterEgg((e) => (e ? { ...e, affection: Math.max(0, e.affection - 1) } : e))
        nextTickAtRef.current = Date.now() + 3600000
      }, 80)
    }, 400)
  }

  const startHoldIncrease = () => {
    if (!centerEgg) return
    clearHold()
    holdTimeoutRef.current = setTimeout(() => {
      holdTimeoutRef.current = null
      holdIntervalRef.current = setInterval(() => {
        setCenterEgg((e) => (e ? { ...e, affection: Math.min(HATCH_MAX, e.affection + 1) } : e))
        nextTickAtRef.current = Date.now() + 3600000
      }, 80)
    }, 400)
  }

  // í•„ë“œ íƒ­ì„ ë²—ì–´ë‚  ë•Œ ëª¬ìŠ¤í„° í¬ì¸í„° ìº¡ì²˜ í•´ì œ + ìƒíƒœ ì´ˆê¸°í™” (íƒ­ ì „í™˜ í›„ ì˜¤ì¸ ì´ë²¤íŠ¸ ë°©ì§€)
  const releaseFieldMonsterPointer = () => {
    const el = fieldMonsterDivRef.current
    const pid = fieldMonsterPointerIdRef.current
    if (el && pid != null) {
      try {
        el.releasePointerCapture(pid)
      } catch (_) { /* ì´ë¯¸ í•´ì œëì„ ìˆ˜ ìˆìŒ */ }
      fieldMonsterPointerIdRef.current = null
    }
    fieldMonsterTouchStartedRef.current = false
    fieldMonsterPointerDownRef.current = false
    fieldMonsterClickSkipRef.current = false
    fieldPointerReleasedAtRef.current = Date.now()
  }

  useEffect(() => {
    if (tab === 'field') return
    releaseFieldMonsterPointer()
  }, [tab])

  // í•„ë“œ ëª¬ìŠ¤í„°: ì§€ê¸ˆë³´ë‹¤ 1.5ë°° í¬ê¸°, ì¢Œìš°Â·ìœ„ì•„ë˜ë¡œ ì´ë™
  useEffect(() => {
    if (tab !== 'field' || !fieldMonster) return
    const el = fieldAreaRef.current
    if (el) {
      const rect = el.getBoundingClientRect()
      const w = rect.width || 300
      setFieldMonsterMaxWidthPx(Math.floor(w * 1.5)) // 1.5ë°°
    }
    const tick = () => {
      setFieldMonsterPos({
        x: 38 + Math.random() * 24, // ì¢Œìš° 38%~62%
        y: 48 + Math.random() * 10, // ìœ„ì•„ë˜ 48%~58%
      })
    }
    const t1 = setTimeout(tick, 100)
    const t2 = setInterval(tick, 3000)
    return () => { clearTimeout(t1); clearInterval(t2) }
  }, [tab, fieldMonster])

  const handleFieldReset = () => {
    setFieldMonster(null)
  }

  const handleSanctuaryReset = () => {
    setSanctuary(Array(SANCTUARY_SLOT_COUNT).fill(null))
  }

  // ì•ˆì‹ì²˜ ëª¬ìŠ¤í„° í„°ì¹˜ â†’ 'í•„ë“œë¡œ ë‚´ë³´ë‚´ì‹œê² ìŠµë‹ˆê¹Œ?' ë‹¤ì´ì–¼ë¡œê·¸
  const handleSanctuarySlotClick = (index) => {
    if (!sanctuary[index]) return
    setSanctuarySlotToField(index)
    setSanctuaryToFieldOpen(true)
  }

  const handleMonsterNameEditOpen = () => {
    setMonsterNameEditTarget('field')
    setMonsterNameEditValue((fieldMonster && (fieldMonster.name ?? '').trim()) || '')
  }

  const handleMonsterNameEditConfirm = () => {
    if (monsterNameEditTarget === 'field' && fieldMonster) {
      setFieldMonster({ ...fieldMonster, name: monsterNameEditValue.trim() || '' })
    }
    setMonsterNameEditTarget(null)
    setMonsterNameEditValue('')
  }

  const handleMonsterNameEditCancel = () => {
    setMonsterNameEditTarget(null)
    setMonsterNameEditValue('')
  }

  const handleSanctuaryToFieldAccept = () => {
    if (sanctuarySlotToField == null) {
      setSanctuaryToFieldOpen(false)
      setSanctuarySlotToField(null)
      return
    }
    const sanctuaryMonster = sanctuary[sanctuarySlotToField]
    if (!sanctuaryMonster) {
      setSanctuaryToFieldOpen(false)
      setSanctuarySlotToField(null)
      return
    }
    if (fieldMonster) {
      setFieldMonster(normalizeFieldMonster(sanctuaryMonster))
      setSanctuary((prev) => {
        const next = [...prev]
        next[sanctuarySlotToField] = fieldMonster
        return next
      })
    } else {
      setFieldMonster(normalizeFieldMonster(sanctuaryMonster))
      setSanctuary((prev) => {
        const next = [...prev]
        next[sanctuarySlotToField] = null
        return next
      })
    }
    setSanctuaryToFieldOpen(false)
    setSanctuarySlotToField(null)
  }

  const handleSanctuaryToFieldReject = () => {
    setSanctuaryToFieldOpen(false)
    setSanctuarySlotToField(null)
  }

  // ë°°ê³ í”” ì‹¤ì‹œê°„ ê°ì†Œ í‘œì‹œ: í•„ë“œ íƒ­ì—ì„œ 60ì´ˆë§ˆë‹¤ ë¦¬ë Œë”
  useEffect(() => {
    if (tab !== 'field' || !fieldMonster) return
    const id = setInterval(() => setFieldHungerTick((t) => t + 1), 60000)
    return () => clearInterval(id)
  }, [tab, fieldMonster])

  // ê²Œì´ì§€ ì¡°ì •: +/- ë²„íŠ¼
  const handleGaugeAdjust = (type, delta) => {
    if (!fieldMonster) return
    const m = fieldMonster
    if (type === 'hunger') {
      const current = getCurrentHunger(m)
      const next = Math.max(0, Math.min(GAUGE_MAX, current + delta))
      setFieldMonster({ ...m, hunger: next, lastHungerUpdatedAt: Date.now() })
    } else if (type === 'happiness') {
      const next = Math.max(0, Math.min(GAUGE_MAX, (m.happiness ?? 0) + delta))
      setFieldMonster({ ...m, happiness: next })
    } else if (type === 'exp') {
      const maxExp = getExpToNextLevel(m.level ?? 1)
      const next = Math.max(0, Math.min(maxExp - 1, (m.exp ?? 0) + delta))
      setFieldMonster({ ...m, exp: next })
    }
  }

  // í•„ë“œ ëª¬ìŠ¤í„° í„°ì¹˜ ì‹œ ì¢‹ì•„í•˜ëŠ” ëŠë‚Œ: í•˜íŠ¸ê°€ ì¢ŒÂ·ìš°Â·ìœ„ë¡œ ëœë¤í•˜ê²Œ ë– ì˜¤ë¦„
  const handleFieldMonsterTouch = () => {
    if (!fieldMonster) return
    const now = Date.now()
    // í•„ë“œ íƒ­ìœ¼ë¡œ ì „í™˜ ì§í›„(600ms) ë™ì•ˆì€ ì˜¤ì¸ í„°ì¹˜ ë¬´ì‹œ
    if (now - fieldTabShownAtRef.current < 600) return
    // í¬ì¸í„° í•´ì œ ì§í›„(550ms) ë™ì•ˆë„ ë¬´ì‹œ â€” ë¹ ë¥¸ íƒ­ ì™”ë‹¤ê°”ë‹¤ ì‹œ ì˜¤ì¸ ë°©ì§€
    if (now - fieldPointerReleasedAtRef.current < 550) return
    const batchId = Date.now()
    setFieldLikeHearts((prev) => [
      ...prev,
      ...Array.from({ length: 5 }, (_, i) => ({
        id: batchId + i,
        batchId,
        dx: (Math.random() - 0.5) * 70,
        dy: (Math.random() - 0.5) * 20,
      })),
    ])
    setFieldMonsterLiking(true)
    if (fieldLikeTimeoutRef.current) clearTimeout(fieldLikeTimeoutRef.current)
    fieldLikeTimeoutRef.current = setTimeout(() => {
      setFieldLikeHearts((prev) => prev.filter((h) => h.batchId !== batchId))
      fieldLikeTimeoutRef.current = null
    }, 1300)
    setTimeout(() => setFieldMonsterLiking(false), 220)
  }

  // ëŒë´ì£¼ê¸°: ê°„ì‹ì£¼ê¸° â€” ë°°ê³ í”” ìƒìŠ¹(í˜„ì¬ê°’ ê¸°ì¤€), ê²½í—˜ì¹˜Â·ë ˆë²¨ì—…
  const handleCareSnack = () => {
    if (!fieldMonster) return
    const today = todayStr()
    let m = { ...fieldMonster }
    if (m.careDate !== today) {
      m = { ...m, careDate: today, careSnack: 0, carePlay: 0 }
    }
    if (m.careSnack >= CARE_SNACK_MAX_PER_DAY) return
    const currentHunger = getCurrentHunger(m)
    const hunger = Math.min(GAUGE_MAX, currentHunger + HUNGER_PER_SNACK)
    m = { ...m, hunger, lastHungerUpdatedAt: Date.now() }
    let exp = (m.exp ?? 0) + CARE_EXP_PER_SNACK
    let level = m.level ?? 1
    while (exp >= getExpToNextLevel(level)) {
      exp -= getExpToNextLevel(level)
      level++
    }
    setFieldMonster({ ...m, exp, level, careSnack: m.careSnack + 1 })
    setFieldCareExpFlash(CARE_EXP_PER_SNACK)
    setTimeout(() => setFieldCareExpFlash(0), 1500)
  }

  // ëŒë´ì£¼ê¸°: ë†€ì•„ì£¼ê¸° â€” í–‰ë³µë„ ìƒìŠ¹, ê²½í—˜ì¹˜Â·ë ˆë²¨ì—…
  const handleCarePlay = () => {
    if (!fieldMonster) return
    const today = todayStr()
    let m = { ...fieldMonster }
    if (m.careDate !== today) {
      m = { ...m, careDate: today, careSnack: 0, carePlay: 0 }
    }
    if (m.carePlay >= CARE_PLAY_MAX_PER_DAY) return
    const happiness = Math.min(GAUGE_MAX, (m.happiness ?? 0) + HAPPINESS_PER_PLAY)
    let exp = (m.exp ?? 0) + CARE_EXP_PER_PLAY
    let level = m.level ?? 1
    while (exp >= getExpToNextLevel(level)) {
      exp -= getExpToNextLevel(level)
      level++
    }
    setFieldMonster({ ...m, happiness, exp, level, carePlay: m.carePlay + 1 })
    setFieldCareExpFlash(CARE_EXP_PER_PLAY)
    setTimeout(() => setFieldCareExpFlash(0), 1500)
  }

  if (!session) {
    return <LoginScreen />
  }

  // ë‹‰ë„¤ì„ ì…ë ¥ í™”ë©´
  if (nicknamePrompt) {
    return (
      <div className="app">
        <div className="nickname-prompt-overlay">
          <div className="nickname-prompt-box">
            <h2>ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”</h2>
            <input
              type="text"
              value={nicknameInput}
              onChange={(e) => setNicknameInput(e.target.value)}
              placeholder="2-10ì"
              maxLength={10}
              autoFocus
            />
            {nicknameError && <div className="nickname-error">{nicknameError}</div>}
            <button onClick={handleNicknameSubmit}>í™•ì¸</button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className={`app ${tab === 'egg' ? 'app--bg-egg' : ''} ${tab === 'field' ? 'app--bg-field' : ''} ${tab === 'sanctuary' ? 'app--bg-sanctuary' : ''}`}>
      <div className="dev-coords" aria-hidden="true">
        <div>x: {devCoords.x} Â· y: {devCoords.y}</div>
        <div>viewport: {devViewport.w}Ã—{devViewport.h}</div>
      </div>
      <div className="app-frame">
        {/* ì•ˆë‚´ ë©”ì‹œì§€ - ê²Œì„ í™”ë©´ ì•ˆì—ì„œ í‘œì‹œ */}
        {note && (
          <div
            className="note-overlay"
            onClick={() => setNote('')}
            role="alertdialog"
            aria-modal="true"
          >
            <div className="note-message">
              {note}
              <div className="note-hint">íƒ­í•˜ì—¬ ë‹«ê¸°</div>
            </div>
          </div>
        )}

        <main className="main">
          {tab === 'egg' && (
            <>
              <div className="user-area">
                <div className="user-name" title="ë¡œê·¸ì•„ì›ƒí•˜ë ¤ë©´ í´ë¦­">
                  <button type="button" className="user-name-btn" onClick={handleLogout} aria-label="ìœ ì € ì´ë¦„ Â· ë¡œê·¸ì•„ì›ƒ">
                    {user?.userId || 'Guest'}
                  </button>
                </div>
                <button
                  type="button"
                  className="user-reset-btn"
                  onClick={handleResetSlots}
                  aria-label="ìŠ¬ë¡¯ì— ì•Œ 3ê°œ ì±„ìš°ê¸° (ë¶ˆÂ·ë¬¼ í¬í•¨)"
                >
                  ì´ˆê¸°í™”
                </button>
                <button
                  type="button"
                  className="user-reset-btn"
                  onClick={handleDeleteAllSlots}
                  aria-label="ëª¨ë“  ìŠ¬ë¡¯ ì•Œ ì‚­ì œ"
                >
                  ì•Œ ì‚­ì œ
                </button>
              </div>
              <div className="hud-area">
                <div className="egg-slots" role="list" aria-label="ì•Œ ìŠ¬ë¡¯">
                  {Array.from({ length: EGG_SLOT_COUNT }, (_, i) => {
                    const locked = i >= EGG_SLOT_LOCKED_FROM
                    const egg = slots[i]
                    const hasEgg = !locked && egg != null
                    const canSelect = !centerEgg && hasEgg
                    return (
                      <button
                        key={i}
                        type="button"
                        role="listitem"
                        className={`egg-slot ${hasEgg ? 'egg-slot--has-egg' : 'egg-slot--empty'} ${locked ? 'egg-slot--locked' : ''}`}
                        aria-label={locked ? `ìŠ¬ë¡¯ ${i + 1} ì ê¸ˆ` : hasEgg ? 'ì•Œ ìˆìŒ Â· ë¶€í™”í•˜ë ¤ë©´ íƒ­' : 'ë¹ˆ ìŠ¬ë¡¯'}
                        onClick={() => handleSlotClick(i)}
                        tabIndex={hasEgg || locked ? 0 : -1}
                      >
                        {locked ? (
                          <span className="egg-slot-lock" aria-hidden="true">ğŸ”’</span>
                        ) : hasEgg ? (
                          <img
                            src={getEggImage(egg.eggType)}
                            alt="ì•Œ"
                            className={`egg-slot-img ${getEggConfig(egg.eggType).slotClass ? getEggConfig(egg.eggType).slotClass : ''}`}
                            draggable={false}
                          />
                        ) : (
                          <span className="egg-slot-empty" aria-hidden="true" />
                        )}
                      </button>
                    )
                  })}
                </div>
              </div>
              <EggIncubator
                centerEgg={centerEgg}
                affection={affection}
                gaugeProgress={gaugeProgress}
                remainingMs={remainingMs}
              />
            </>
          )}

          {tab === 'field' && (
            <div className="tab-screen tab-screen--field" aria-label="í•„ë“œ">
              <div className="field-area" ref={fieldAreaRef}>
                {fieldMonster ? (
                  <>
                    {/* ê²Œì´ì§€: í™”ë©´ ìƒë‹¨ (ë°°ê³ í””ì€ 12ì‹œê°„ ê²½ê³¼ ì‹œ 0) */}
                    {(() => {
                      const currentHunger = getCurrentHunger(fieldMonster)
                      const currentHappiness = fieldMonster.happiness ?? GAUGE_MAX
                      const expMax = getExpToNextLevel(fieldMonster.level ?? 1)
                      const expPct = Math.min(100, (100 * (fieldMonster.exp ?? 0)) / expMax)
                      return (
                        <div className="field-care-gauges-top" aria-label="ëª¬ìŠ¤í„° ìƒíƒœ">
                          <div className="field-care-head">
                            <span className="field-care-name">{getDisplayName(fieldMonster)}</span>
                            <button type="button" className="field-care-name-edit" onClick={handleMonsterNameEditOpen} aria-label="ì´ë¦„ í¸ì§‘">í¸ì§‘</button>
                            <span className="field-care-level">Lv.{fieldMonster.level ?? 1}</span>
                          </div>
                          <div className="field-care-gauges">
                            <div className="field-care-gauge-row">
                              <span className="field-care-gauge-label">ë°°ê³ í””</span>
                              <div className="field-care-gauge-wrap" role="progressbar" aria-valuenow={currentHunger} aria-valuemin={0} aria-valuemax={GAUGE_MAX}>
                                <div className="field-care-gauge-bar field-care-gauge-bar--hunger" style={{ width: `${currentHunger}%` }} />
                              </div>
                              <div className="field-care-gauge-btns">
                                <button type="button" className="field-care-gauge-btn" onClick={() => handleGaugeAdjust('hunger', -15)} aria-label="ë°°ê³ í”” ê°ì†Œ">âˆ’</button>
                                <button type="button" className="field-care-gauge-btn" onClick={() => handleGaugeAdjust('hunger', 15)} aria-label="ë°°ê³ í”” ì¦ê°€">+</button>
                              </div>
                            </div>
                            <div className="field-care-gauge-row">
                              <span className="field-care-gauge-label">í–‰ë³µë„</span>
                              <div className="field-care-gauge-wrap" role="progressbar" aria-valuenow={currentHappiness} aria-valuemin={0} aria-valuemax={GAUGE_MAX}>
                                <div className="field-care-gauge-bar field-care-gauge-bar--happiness" style={{ width: `${currentHappiness}%` }} />
                              </div>
                              <div className="field-care-gauge-btns">
                                <button type="button" className="field-care-gauge-btn" onClick={() => handleGaugeAdjust('happiness', -15)} aria-label="í–‰ë³µë„ ê°ì†Œ">âˆ’</button>
                                <button type="button" className="field-care-gauge-btn" onClick={() => handleGaugeAdjust('happiness', 15)} aria-label="í–‰ë³µë„ ì¦ê°€">+</button>
                              </div>
                            </div>
                            <div className="field-care-gauge-row field-care-exp-row">
                              <span className="field-care-gauge-label">EXP</span>
                              <div className="field-care-gauge-wrap field-care-exp-wrap" role="progressbar" aria-valuenow={fieldMonster.exp ?? 0} aria-valuemin={0} aria-valuemax={expMax}>
                                <div className="field-care-gauge-bar field-care-exp-bar" style={{ width: `${expPct}%` }} />
                              </div>
                              <div className="field-care-gauge-btns">
                                <button type="button" className="field-care-gauge-btn" onClick={() => handleGaugeAdjust('exp', -20)} aria-label="EXP ê°ì†Œ">âˆ’</button>
                                <button type="button" className="field-care-gauge-btn" onClick={() => handleGaugeAdjust('exp', 20)} aria-label="EXP ì¦ê°€">+</button>
                              </div>
                            </div>
                          </div>
                        </div>
                      )
                    })()}
                    {/* ê°„ì‹ì£¼ê¸°Â·ë†€ì•„ì£¼ê¸°: í™”ë©´ í•˜ë‹¨ */}
                    <div className="field-care-actions-bottom" aria-label="ëŒë´ì£¼ê¸°">
                      {fieldCareExpFlash > 0 && (
                        <span className="field-care-exp-flash" aria-hidden="true">+{fieldCareExpFlash} EXP</span>
                      )}
                      <div className="field-care-actions">
                        <button type="button" className="field-care-btn" onClick={handleCareSnack} disabled={(fieldMonster.careSnack ?? 0) >= CARE_SNACK_MAX_PER_DAY} aria-label={`ê°„ì‹ì£¼ê¸° (ì˜¤ëŠ˜ ${fieldMonster.careSnack ?? 0}/${CARE_SNACK_MAX_PER_DAY}íšŒ)`}>
                          ê°„ì‹ì£¼ê¸°
                        </button>
                        <button type="button" className="field-care-btn" onClick={handleCarePlay} disabled={(fieldMonster.carePlay ?? 0) >= CARE_PLAY_MAX_PER_DAY} aria-label={`ë†€ì•„ì£¼ê¸° (ì˜¤ëŠ˜ ${fieldMonster.carePlay ?? 0}/${CARE_PLAY_MAX_PER_DAY}íšŒ)`}>
                          ë†€ì•„ì£¼ê¸°
                        </button>
                      </div>
                    </div>
                    <div
                      ref={fieldMonsterDivRef}
                      className={`field-monster ${fieldMonsterLiking ? 'field-monster--liking' : ''} ${fieldMonsterPos.x < 50 ? 'field-monster--facing-left' : ''}`}
                      style={{
                        left: `${fieldMonsterPos.x}%`,
                        top: `${fieldMonsterPos.y}%`,
                      }}
                      onPointerDown={(e) => {
                        fieldMonsterPointerDownRef.current = true
                        e.currentTarget.setPointerCapture(e.pointerId)
                        fieldMonsterPointerIdRef.current = e.pointerId
                      }}
                      onPointerUp={(e) => {
                        try { e.currentTarget.releasePointerCapture(e.pointerId) } catch (_) { }
                        fieldMonsterPointerIdRef.current = null
                        setTimeout(() => { fieldMonsterPointerDownRef.current = false }, 0)
                      }}
                      onPointerLeave={(e) => {
                        try { e.currentTarget.releasePointerCapture(e.pointerId) } catch (_) { }
                        fieldMonsterPointerIdRef.current = null
                        setTimeout(() => { fieldMonsterPointerDownRef.current = false }, 0)
                      }}
                      onPointerCancel={(e) => {
                        try { e.currentTarget.releasePointerCapture(e.pointerId) } catch (_) { }
                        fieldMonsterPointerIdRef.current = null
                        setTimeout(() => { fieldMonsterPointerDownRef.current = false }, 0)
                      }}
                      onTouchStart={() => { fieldMonsterTouchStartedRef.current = true }}
                      onTouchEnd={(e) => {
                        e.preventDefault()
                        if (fieldMonsterTouchStartedRef.current) {
                          handleFieldMonsterTouch()
                          fieldMonsterClickSkipRef.current = true
                          setTimeout(() => { fieldMonsterClickSkipRef.current = false }, 350)
                        }
                        fieldMonsterTouchStartedRef.current = false
                      }}
                      onClick={() => {
                        if (fieldMonsterClickSkipRef.current) return
                        if (!fieldMonsterPointerDownRef.current) return
                        fieldMonsterPointerDownRef.current = false
                        handleFieldMonsterTouch()
                      }}
                      role="button"
                      aria-label="ëª¬ìŠ¤í„° í„°ì¹˜"
                    >
                      <img
                        src={getMonsterImage(fieldMonster.element)}
                        alt="í•„ë“œ ëª¬ìŠ¤í„°"
                        className="field-monster-img"
                        style={fieldMonsterMaxWidthPx != null ? { maxWidth: `${fieldMonsterMaxWidthPx}px` } : undefined}
                        draggable={false}
                      />
                      {fieldLikeHearts.map((h) => (
                        <span
                          key={h.id}
                          className="field-like-heart"
                          style={{ '--dx': `${h.dx ?? 0}px`, '--dy': `${h.dy ?? 0}px` }}
                          aria-hidden="true"
                        >
                          â™¥
                        </span>
                      ))}
                    </div>
                    <button
                      type="button"
                      className="field-reset-btn"
                      onClick={handleFieldReset}
                      aria-label="í•„ë“œ ì´ˆê¸°í™”"
                    >
                      í•„ë“œ ì´ˆê¸°í™”
                    </button>
                  </>
                ) : (
                  <p className="field-empty">í•„ë“œì— ëª¬ìŠ¤í„°ê°€ ì—†ì–´ìš”. ì•Œì„ ë¶€í™”ì‹œí‚¤ë©´ ì—¬ê¸°ë¡œ ì™€ìš”.</p>
                )}
              </div>
            </div>
          )}

          {tab === 'sanctuary' && (
            <div className="tab-screen tab-screen--sanctuary">
              <button
                type="button"
                className="sanctuary-reset-btn"
                onClick={handleSanctuaryReset}
                aria-label="ì•ˆì‹ì²˜ ì´ˆê¸°í™”"
              >
                ì•ˆì‹ì²˜ ì´ˆê¸°í™”
              </button>
              <div className="sanctuary-slots" role="list" aria-label="ì•ˆì‹ì²˜ ëª¬ìŠ¤í„° ìŠ¬ë¡¯">
                {Array.from({ length: SANCTUARY_SLOT_COUNT }, (_, i) => {
                  const m = sanctuary[i]
                  return (
                    <div
                      key={m ? m.id : `empty-${i}`}
                      className={`sanctuary-slot ${m ? 'sanctuary-slot--has-monster' : 'sanctuary-slot--empty'}`}
                      role={m ? 'button' : 'listitem'}
                      onClick={m ? () => handleSanctuarySlotClick(i) : undefined}
                      onKeyDown={m ? (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); handleSanctuarySlotClick(i); } } : undefined}
                      tabIndex={m ? 0 : -1}
                      aria-label={m ? `${getDisplayName(m)} Lv.${m.level ?? 1}, í•„ë“œë¡œ ë‚´ë³´ë‚´ê¸°` : undefined}
                    >
                      {m ? (
                        <>
                          <div className="sanctuary-slot-info" aria-hidden="true">
                            <span className="sanctuary-slot-level">Lv.{m.level ?? 1}</span>
                            <span className="sanctuary-slot-name">{getDisplayName(m)}</span>
                          </div>
                          <img
                            src={getMonsterImage(m.element)}
                            alt=""
                            className="sanctuary-slot-img"
                            draggable={false}
                          />
                        </>
                      ) : (
                        <span className="sanctuary-slot-empty" aria-hidden="true" />
                      )}
                    </div>
                  )
                })}
              </div>
            </div>
          )}
        </main>

        {/* Monster component removed - using direct img rendering instead */}
        {/* {tab === 'egg' && centerEgg != null && !hatchDismissed && (
          <Monster
            mood={mood}
            bondStage={bondStage}
            affection={affection}
            element={centerEgg.element ?? DEFAULT_ELEMENT}
            eggType={centerEgg.eggType ?? getEggTypeByElement(centerEgg.element)}
            note={note}
            onTouch={handleMonsterTouch}
            onHatch={() => { }}
            onHatchDismiss={handleHatchDismiss}
            readyToHatch={affection >= HATCH_MAX}
          />
        )} */}
        {tab === 'egg' && centerEgg && (
          <>
            <div className="dev-affection" aria-label="ë¶€í™” ì¡°ì ˆ (ê°œë°œìš©)">
              <button
                type="button"
                className="dev-affection-btn"
                title="ë¶€í™” -1 (ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ì—°ì† ê°ì†Œ)"
                onClick={() => {
                  setCenterEgg((e) => (e ? { ...e, affection: Math.max(0, e.affection - 1) } : e))
                  nextTickAtRef.current = Date.now() + 3600000
                }}
                onMouseDown={startHoldDecrease}
                onMouseUp={clearHold}
                onMouseLeave={clearHold}
                onTouchStart={(e) => {
                  e.preventDefault()
                  startHoldDecrease()
                }}
                onTouchEnd={clearHold}
                onTouchCancel={clearHold}
              >
                âˆ’
              </button>
              <span className="dev-affection-label">ë¶€í™”</span>
              <button
                type="button"
                className="dev-affection-btn"
                title="ë¶€í™” +1 (ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ì—°ì† ì¦ê°€)"
                onClick={() => {
                  setCenterEgg((e) => (e ? { ...e, affection: Math.min(HATCH_MAX, e.affection + 1) } : e))
                  nextTickAtRef.current = Date.now() + 3600000
                }}
                onMouseDown={startHoldIncrease}
                onMouseUp={clearHold}
                onMouseLeave={clearHold}
                onTouchStart={(e) => {
                  e.preventDefault()
                  startHoldIncrease()
                }}
                onTouchEnd={clearHold}
                onTouchCancel={clearHold}
              >
                ï¼‹
              </button>
            </div>
          </>
        )}

        <nav className="bottom-nav" aria-label="ë©”ì¸ ë©”ë‰´">
          <button
            type="button"
            className={`bottom-nav-btn ${tab === 'egg' ? 'bottom-nav-btn--active' : ''}`}
            onClick={() => {
              releaseFieldMonsterPointer()
              setTab('egg')
            }}
            aria-current={tab === 'egg' ? 'page' : undefined}
          >
            ì•Œ
          </button>
          <button
            type="button"
            className={`bottom-nav-btn ${tab === 'field' ? 'bottom-nav-btn--active' : ''}`}
            onClick={() => {
              fieldTabShownAtRef.current = Date.now()
              setTab('field')
            }}
            aria-current={tab === 'field' ? 'page' : undefined}
          >
            í•„ë“œ
          </button>
          <button
            type="button"
            className={`bottom-nav-btn ${tab === 'sanctuary' ? 'bottom-nav-btn--active' : ''}`}
            onClick={() => {
              releaseFieldMonsterPointer()
              setTab('sanctuary')
            }}
            aria-current={tab === 'sanctuary' ? 'page' : undefined}
          >
            ì•ˆì‹ì²˜
          </button>
        </nav>

        {/* ë¶€í™” í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸: ìŠ¬ë¡¯ ì•Œ â†’ ê°€ìš´ë°ë¡œ */}
        {confirmHatchOpen && (
          <div className="modal-overlay confirm-hatch-overlay" role="alertdialog" aria-modal="true" aria-labelledby="confirm-hatch-title">
            <div className="confirm-hatch-dialog">
              <p id="confirm-hatch-title" className="confirm-hatch-text">ë¶€í™”ë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
              <div className="confirm-hatch-actions">
                <button type="button" className="confirm-hatch-btn confirm-hatch-btn--reject" onClick={handleConfirmHatchReject}>
                  ì•„ë‹ˆì˜¤
                </button>
                <button type="button" className="confirm-hatch-btn confirm-hatch-btn--accept" onClick={handleConfirmHatchAccept}>
                  ì˜ˆ
                </button>
              </div>
            </div>
          </div>
        )}

        {/* ëª¬ìŠ¤í„° ì´ë¦„ ìˆ˜ì • ëª¨ë‹¬ (í•„ë“œ ëª¬ìŠ¤í„°) */}
        {monsterNameEditTarget != null && (
          <div className="modal-overlay confirm-hatch-overlay" role="dialog" aria-modal="true" aria-labelledby="monster-name-edit-title">
            <div className="confirm-hatch-dialog monster-name-edit-dialog">
              <p id="monster-name-edit-title" className="confirm-hatch-text">ëª¬ìŠ¤í„° ì´ë¦„</p>
              <input
                type="text"
                className="monster-name-edit-input"
                value={monsterNameEditValue}
                onChange={(e) => setMonsterNameEditValue(e.target.value)}
                placeholder="ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”"
                maxLength={20}
                aria-label="ëª¬ìŠ¤í„° ì´ë¦„"
                autoFocus
              />
              <div className="confirm-hatch-actions">
                <button type="button" className="confirm-hatch-btn confirm-hatch-btn--reject" onClick={handleMonsterNameEditCancel}>
                  ì·¨ì†Œ
                </button>
                <button type="button" className="confirm-hatch-btn confirm-hatch-btn--accept" onClick={handleMonsterNameEditConfirm}>
                  í™•ì¸
                </button>
              </div>
            </div>
          </div>
        )}

        {/* ì ê¸ˆ ìŠ¬ë¡¯ ì•Œë¦¼ ë‹¤ì´ì–¼ë¡œê·¸ */}
        {slotLockedAlertOpen && (
          <div className="modal-overlay confirm-hatch-overlay" role="alertdialog" aria-modal="true" aria-labelledby="slot-locked-title">
            <div className="confirm-hatch-dialog">
              <p id="slot-locked-title" className="confirm-hatch-text">ìŠ¬ë¡¯ì´ ì ê²¨ìˆìŠµë‹ˆë‹¤.</p>
              <div className="confirm-hatch-actions">
                <button type="button" className="confirm-hatch-btn confirm-hatch-btn--accept" onClick={() => setSlotLockedAlertOpen(false)}>
                  í™•ì¸
                </button>
              </div>
            </div>
          </div>
        )}

        {/* ë¶€í™”ì¥ì¹˜ ë§Œì„ ì•Œë¦¼ ë‹¤ì´ì–¼ë¡œê·¸ */}
        {slotFullAlertOpen && (
          <div className="modal-overlay confirm-hatch-overlay" role="alertdialog" aria-modal="true" aria-labelledby="slot-full-title">
            <div className="confirm-hatch-dialog">
              <p id="slot-full-title" className="confirm-hatch-text">ë¶€í™”ì¥ì¹˜ì— ì´ë¯¸ ì•Œì´ ìˆìŠµë‹ˆë‹¤.</p>
              <div className="confirm-hatch-actions">
                <button type="button" className="confirm-hatch-btn confirm-hatch-btn--accept" onClick={() => setSlotFullAlertOpen(false)}>
                  í™•ì¸
                </button>
              </div>
            </div>
          </div>
        )}


        {/* ì•ˆì‹ì²˜ â†’ í•„ë“œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ */}
        {sanctuaryToFieldOpen && (
          <div className="modal-overlay confirm-hatch-overlay" role="alertdialog" aria-modal="true" aria-labelledby="sanctuary-to-field-title">
            <div className="confirm-hatch-dialog">
              <p id="sanctuary-to-field-title" className="confirm-hatch-text">í•„ë“œë¡œ ë‚´ë³´ë‚´ì‹œê² ìŠµë‹ˆê¹Œ?</p>
              <div className="confirm-hatch-actions">
                <button type="button" className="confirm-hatch-btn confirm-hatch-btn--reject" onClick={handleSanctuaryToFieldReject}>
                  ì•„ë‹ˆì˜¤
                </button>
                <button type="button" className="confirm-hatch-btn confirm-hatch-btn--accept" onClick={handleSanctuaryToFieldAccept}>
                  ì˜ˆ
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div >
  )
}

export default App
